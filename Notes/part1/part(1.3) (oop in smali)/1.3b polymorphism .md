ok in java we know that an animal object type refernce vribel can hold a dog or cat object type assumin they both extend the former one.
now look at this java snipt
```java
Animal animal;
Animal animal2;
```
now botht hare animal reffernce at compile time the compiler can only see the fields that are riprsented by those two.
now lets asumm dog and cat are object of Dog and Cat class repectivelty

```
animal = dog;
animal2 = cat;
```
and lets asuume the DOg class and the Cat class have overrode the makeSound() methode.

```
animal.makeSound();
```
now sinc eht emthode makesoun is present in the animal class compilation will lets us compile but duirng the runtime the make sound of the overloaded will be 

now we will see how this is implemetn in smali.
in smali we use the too things

#invoke-vertuall;
when calllign a methode if you see this in smali it means i dont care the type of class that is there i just need you to eqcute the methode.
```smali
#assum v0 holds the dog object
invoke-vertual {v0}, L/pets/Animal;->makeSound()V
```
now what is happengin in this smalei code is we are tellign to find and exuct the makeSound()V of the object v0 with out regard to the ANimal class.
this is the same as *dog.makeSund* in java 
#invoke-vertuall;
when usign this the object type does matter, and this meand that object methode will be excuted.
```smali
#assume v0 hold the reffecne to an actuall dog Obejct
invoke-vertual {v0}, L/pets/Animals;->makeSound()V
# this is the same as
invoke-direct {v0}, L/pets/Dog;->makeSound()V
```
this is poymorphisum at its finest even though the reffence type of the object is being treated us animal since the obejct is Dog it will excute the makeSound of the dog;
```smali
invoke-direct{v0}, L/pets/Animals; -> makeSound()V
#now this woudl be the same with the follwoign if Dog didnt ovrride the methode makeSOund();
invoke-vertual{v0}, L/pets/Animals; -> makeSound()V
```
now this oen is telling the vm i dotn care aout the object is just fidn the field in the super class adn exucute that exact field 

# Exersise 

```Java
public class User {
    public String getRole() {
        return "User";
    }
}

public class Admin extends User {
    @Override 
    public String getRole() {
        return "Admin";
    }
}
```
now look at this smali code that is calling those methodes

```smali
# Assume v0 holds an object of type Lcom/example/Admin;

# --- Call 1 ---
invoke-virtual {v0}, Lcom/example/Admin;->getRole()Ljava/lang/String;
move-result-object v1 # Result of call 1 is stored in v1

# --- Call 2 ---
invoke-direct {v0}, Lcom/example/User;->getRole()Ljava/lang/String;
move-result-object v2 # Result of call 2 is stored in v2
```
now answer the follwign bassed on that
1. Call 1 (invoke-virtual): What string value will be in register v1 after this call executes? Explain why, based on how invoke-virtual works.
2. Call 2 (invoke-direct): What string value will be in register v2 after this call executes? Explain why, based on how invoke-direct works.
3. The "Why": Why is understanding this difference absolutely critical for a reversing this

Answer;
1. the -vertuall parameter signals the vm for poly morphisum and says even if the referce type is user type tret the object for what it is and call the methode on the object
and this would return the admin, this woudl also be the same with invoke-direct {vo}, Llcom/examle/Admin. 
2. the -direct paremte flags teh opration for the vm as i dont care abotu polymorphisum call the methode on the reffecne type in this case it is user so i returns the
user.
3, you wouldnt know which methode is biend implement with out solid understanding here
