So, you tap on our target app, now what happens is the zygot process get copied with fork,  and will have the intery tabel( which is read only) and direcctly indicate to the target android frame work zygot.
then you are app will have its memeory allocated. but now the ART know it want to call the MainActiicivity class's oncreat omethdoe but it cant do it since there is no class object of that classs to creat a new object and
excute the byte codes. so it has to find a way to actaully creat this class from the apps .apk file and here is where the `ClassLoader` comes in.

this class is created and mantained by the zygotprocess which has noe become the app, so the zygot doesnt need a way to load it unlike othere.

so firt lets look at what the classLoader abstract class look like in java so that we can undersadn it better.

```java
Class abstract ClassLoader{
# feild to store the parent classLoader
ClassLoader parent;

#Constractor to set the parent class loader

ClassLoader (ClassLoader, "path to the app"){
this.parent = ClassLoader
}


# this methode has algorizum to check the cache of this class to make sure if the class had been loaded before and returns the class
class<?> findLoadedClass("Class name in the app"){

}

this is where the deligation to parent loader happens
class<?> loadClass ("class name in the app") throws NotfoundException{

# if parent is not null  it woudl mean this class loader has a paren and is not the BottLoader( the loader that loads class form the know android frame work)
if (parent !=null) {
try{
class<?> C = parent.loadClass(p0);
return C
}
catthc(e) {
# thi swoudl mean we deligate teh resposiblity of fidn the class to parent loader but it has rhough the classNotFoundException that is nto a bigie thsi catch will solow that silentl
}
}

else {
# this woudl mean this is the BootLoader and should call on the findClass() ASAP; it has no one ot delfgate the requist to
}

# the final call to fidn the class on its own after its parent failed
class<?> C = this.findClass(p0);

}
# this is the method that the load class will call andn that every classLoader wenna be class shoudl provide a concreat emplimentation on how to find the class
Class<?> abstract findClass(String s ){}
}
```

now the abovve is just a repsentation of what the stracturre the lofic on how thte calss are loaded by the findclass is implment by class that extend this abstract class. now, 
lets look it wiht exmpale lets use the variane of the class loader that is PathClassLoader. whoc main job is to loaded class from `class.dex `  

so the zygot will also have class object for this class so, you should know it extendes the ClassLoader abstract class

now
```PathClassLoader appClassLoader = new PathClassLoader("po.apk", BootClassLoader);```
this happens what this means is the zygot will creat an object with the feilds that knwowhich app to work on and the parent bing the BootClassLoaderClassLoader 

and since it wanted the MainActivity class( it migh have a better naming but we will assume this class Extendes the Activity class.

so now our zygot prosses or the Os will call `appClassLoader.loadClass(com.po.MainActivity)`.
1. it will first excute the `findLoadedClass(com.po.MainActivity)`
2. assuming this is the first time the app is runnin after bing closed it wont find any so the methode wont exit
3. it then it calles `loadClass` on the parent classLoader in this case which is BoatclassLoader.
4. since MainActivity is not an andorid frame work defined class it woudl then return a notfoundException which will singnal for this metdhe to run then its own `findClas(com.po.MainActivity)`
5. it will find it and return the class object, but before storing it in to the **meta space** where class obects are stored it chaches it meaning, soon if any one asks findClass for any reason it woudl find the
class in the step numeb 1
6, the class is found and the metadata for all the MainActicity class ( which is the MainAcctivity class object) is store in the meta space ( this  is part of the memroy that wont undergo gabagecollection)
now the zygot can do `new MainActivity` and then an object willbe imdiatley be created from the meta data.

intersitng point here is the MainActivity class extend the Acitivyt class, so when this class was put in to the meta data java to make things perform faster they only include sting refferse ot this Acitivyt class, 
maining until the MainActicity class or any class that Extends it undergoas the `new MainActivity` call Art wont bothere crea and pooting it in the `meta space`.

but lets see what happens when it calles `new MainActivity`
so the first thign its see is that this extend the `android.framework.actviity` class so on the alred crreath pathloaderobject loadclass() is called. and the thing goes teh same way as beforre expet when it reaches
step 3 sine the bootclassLoader is ment to work with the android framewokr classes it will find it ,cache it and return it, so now we have a blurpint or the class object of the Activity class in the meta space.

now we call this *lazy loading* or *just in time*, this saves huge amoutn of overhead exctions cpu coast and memroy space, only load what is need in to the metaspace..

so back to out classLoaders,
we will see tha type they are
but forr now just knwo the `PathClassLoader` is meant to load classfrom an apk
and `DexClassLoader` is meant to load class from an a specific dex file.

# why do we need to implemten the parent deligation first
this is for secrruity + performace reasons, now if as in the past expale, we didn delegate the reposiblity of loading the Aciticity class to the BootClassLoader, 
1. our path loader could have been Hijacked and brough us a floud Activity class, but by ensuring the BootClassLoader is called we are making sure the rigth Acititicy or any andeori frame clas is bing pulled
2. it is for speed, since Accicity woudl have benn called by othere precces inside the app, making sure by calling the BooClassLoader we will get a fast feedback if the class is already in the `meta space`

